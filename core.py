from flask import Flask, render_template, request, send_file, abort, jsonify, redirect, url_for
import gc
from multiprocessing import Array
from urllib.error import HTTPError
from urllib.parse import quote_plus, unquote_plus
from werkzeug.utils import secure_filename

from lib.config_manager import *
from lib.app_utils import *
from lib.custom_logger import *
from lib import revise_code

import gevent
from gevent import pywsgi
from gevent.pywsgi import WSGIServer
from gevent.queue import Queue
from gevent.pool import Pool
from gevent.pywsgi import WSGIServer

app = Flask(__name__)

if not os.path.exists(get_config("log_folder","")):
    os.makedirs(get_config("log_folder",""))

logger = CustomLogger(get_config("log_folder",""))

# Set defaults if not present in the config
app.secret_key = get_config('secret_key', '')
app.config['MODEL_FOLDER'] = get_config('model_folder', '')
app.config['MODEL_URL'] = get_config('model_url', "")
app.config['MODEL_FILENAME'] = get_config('model', "")
app.config['MAX_CONTEXT'] = get_config('n_ctx', "")
app.config['REVISIONS_PER_PAGE'] = get_config('revisions_per_page', "")
app.config['SESSION_TYPE'] = get_config('session_type', '')
app.config['MAX_FILE_SIZE'] = get_config('max_file_size', "")

@app.route('/process_request_creative', methods=['POST'])
def process_request_creative():
    return process_request(app.config["MODEL_FILENAME_CREATIVE"])

@app.route('/process_request_cleanup', methods=['POST'])
def process_request_cleanup():
    return process_request(app.config["MODEL_FILENAME_CLEANUP"])


def process_request(model_filename):

    data = request.get_json() if request.is_json else request.form

    # Get the current ticks as a string
    now = datetime.datetime.now()
    current_ticks = now.strftime("%Y%m%d_%H%M%S")

    # Save the dictionary as a JSON file with the current ticks as the name
    with open(f"{get_config("log_folder")}data_{current_ticks}.json", "w") as outfile:
        json.dump(data, outfile, indent=4)

    prompt = data.get('prompt', '')
    file_contents = data.get('fileContents', '')

    llm = load_model(app.config['MODEL_URL'], app.config['MODEL_FOLDER'], model_filename, app.config['MAX_CONTEXT'], logger)
    revision = revise_code.run(file_contents, llm, prompt, logger)

    # Save the dictionary as a JSON file with the current ticks as the name
    with open(f"{get_config("log_folder")}response_{current_ticks}.json", "w") as outfile:
        json.dump(revision, outfile, indent=4)

    del llm
    gc.collect()
    time.sleep(10)
    return revision

request_queue = Queue()
worker_pool = Pool(50)

# Wrap the Flask application with a WSGI callable
def handle_request(environ, start_response):
    # Spawn a new greenlet to handle each request using the worker pool
    request = worker_pool.spawn(app.wsgi_app, environ, start_response)
    gevent.joinall([request])  # Wait for the request to complete
    return request.get()  # Return the response generated by Flask

# Create a WSGI server with the gevent event loop
server = pywsgi.WSGIServer((get_config("host",""), int(get_config("port",""))), handle_request, spawn=worker_pool)

if __name__ == '__main__':
    server.serve_forever()

    